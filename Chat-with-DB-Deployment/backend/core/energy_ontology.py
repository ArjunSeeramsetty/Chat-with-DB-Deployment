#!/usr/bin/env python3
"""
Energy Sector Domain Ontology

This module implements a comprehensive energy sector ontology that maps energy concepts
to database schema with explicit constraints. Based on research showing that ontology-driven
approaches can achieve 99.8% accuracy (like App Orchid).

The ontology provides:
1. Energy domain concepts and their relationships
2. Mapping between concepts and database schema
3. Business rules and constraints
4. Validation framework for ontological consistency
"""

import json
import logging
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional, Set, Any, Tuple
from pathlib import Path
import sqlite3
from datetime import datetime

logger = logging.getLogger(__name__)


class EnergyConceptType(Enum):
    """Types of energy concepts in the ontology"""
    ENTITY = "entity"           # Physical entities (states, regions, sources)
    ATTRIBUTE = "attribute"     # Measurable attributes (demand, generation, shortage)
    RELATIONSHIP = "relationship"  # Relationships between entities
    CONSTRAINT = "constraint"   # Business rules and constraints
    OPERATION = "operation"     # Operations and aggregations


class EnergyDomain(Enum):
    """Energy domains in the ontology"""
    GENERATION = "generation"           # Power generation
    CONSUMPTION = "consumption"         # Power consumption
    TRANSMISSION = "transmission"       # Power transmission
    DISTRIBUTION = "distribution"       # Power distribution
    EXCHANGE = "exchange"              # Power exchange
    SHORTAGE = "shortage"              # Power shortage
    DEMAND = "demand"                  # Power demand
    EFFICIENCY = "efficiency"          # System efficiency
    RELIABILITY = "reliability"        # System reliability


@dataclass
class EnergyConcept:
    """Represents an energy concept in the ontology"""
    id: str
    name: str
    concept_type: EnergyConceptType
    domain: EnergyDomain
    description: str
    synonyms: List[str] = field(default_factory=list)
    attributes: Dict[str, Any] = field(default_factory=dict)
    constraints: List[str] = field(default_factory=list)
    database_mapping: Dict[str, str] = field(default_factory=dict)
    relationships: List[str] = field(default_factory=list)
    validation_rules: List[str] = field(default_factory=list)


@dataclass
class OntologyRelationship:
    """Represents a relationship between energy concepts"""
    id: str
    source_concept: str
    target_concept: str
    relationship_type: str
    description: str
    constraints: List[str] = field(default_factory=list)
    cardinality: str = "1:1"  # 1:1, 1:N, N:1, N:N


@dataclass
class BusinessRule:
    """Represents a business rule in the energy domain"""
    id: str
    name: str
    description: str
    rule_type: str  # constraint, validation, calculation
    expression: str
    severity: str = "error"  # error, warning, info
    applicable_domains: List[EnergyDomain] = field(default_factory=list)


class EnergyOntology:
    """
    Comprehensive energy sector domain ontology
    
    Maps energy concepts to database schema with explicit constraints and business rules.
    Provides validation framework for ontological consistency.
    """
    
    def __init__(self, db_path: str = None):
        self.db_path = db_path
        self.concepts: Dict[str, EnergyConcept] = {}
        self.relationships: Dict[str, OntologyRelationship] = {}
        self.business_rules: Dict[str, BusinessRule] = {}
        self.database_schema: Dict[str, Dict] = {}
        
        # Initialize the ontology
        self._initialize_energy_concepts()
        self._initialize_relationships()
        self._initialize_business_rules()
        self._load_database_schema()
        
        logger.info(f"Energy ontology initialized with {len(self.concepts)} concepts, "
                   f"{len(self.relationships)} relationships, and {len(self.business_rules)} business rules")
    
    def _initialize_energy_concepts(self):
        """Initialize energy domain concepts"""
        
        # Generation Concepts - Updated based on power vs energy distinction
        self.concepts["energy_generation"] = EnergyConcept(
            id="energy_generation",
            name="Energy Generation",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.GENERATION,
            description="Energy generated by a particular source in a day (cumulative measurement)",
            synonyms=["energy production", "daily energy generation", "energy output"],
            database_mapping={
                "table": "FactDailyGenerationBreakdown",
                "column": "GenerationAmount"
            },
            attributes={
                "unit": "MU",
                "measurement_type": "cumulative",
                "time_period": "daily",
                "description": "Energy generated by a particular source in a day. This is a cumulative measurement type."
            }
        )
        
        self.concepts["power_generation"] = EnergyConcept(
            id="power_generation",
            name="Power Generation",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.GENERATION,
            description="Power generation capacity utilized in a time block (instantaneous measurement)",
            synonyms=["power production", "generation capacity", "power output"],
            database_mapping={
                "table": "FactTimeBlockGeneration",
                "column": "GenerationOutput"
            },
            attributes={
                "unit": "MW",
                "measurement_type": "instantaneous",
                "time_period": "time_block",
                "description": "Power generation capacity utilized in a time block. This represents the capacity (power) of energy sources utilized in that timeblock."
            }
        )
        
        self.concepts["generation_source"] = EnergyConcept(
            id="generation_source",
            name="Generation Source",
            concept_type=EnergyConceptType.ENTITY,
            domain=EnergyDomain.GENERATION,
            description="Source of power generation (thermal, hydro, solar, wind, etc.)",
            synonyms=["source", "fuel source", "generation type"],
            database_mapping={
                "table": "DimGenerationSources",
                "column": "SourceName"
            },
            attributes={
                "categories": ["coal", "lignite", "hydro", "solar", "wind", "nuclear", "gas, naptha & diesel", "renewable"]
            }
        )
        
        # Remove the old generation_output concept as it's now split into energy_generation and power_generation
        # self.concepts["generation_output"] = EnergyConcept(...) - REMOVED
        
        # Consumption Concepts - Updated to clarify geographic levels
        self.concepts["energy_consumption"] = EnergyConcept(
            id="energy_consumption",
            name="Energy Consumption",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.CONSUMPTION,
            description="Total energy consumed over a period (cumulative measurement)",
            synonyms=["consumption", "energy demand", "energy usage"],
            database_mapping={
                "state_table": "FactStateDailyEnergy",
                "state_column": "EnergyMet",
                "region_table": "FactAllIndiaDailySummary",
                "region_column": "EnergyMet"
            },
            attributes={
                "unit": "MU",
                "measurement_type": "cumulative",
                "description": "Total energy consumed over a period. Energy is power multiplied by time. Measured at both state level (FactStateDailyEnergy.EnergyMet) and region level (FactAllIndiaDailySummary.EnergyMet).",
                "geographic_levels": ["state", "region"],
                "state_mapping": {
                    "table": "FactStateDailyEnergy",
                    "column": "EnergyMet"
                },
                "region_mapping": {
                    "table": "FactAllIndiaDailySummary",
                    "column": "EnergyMet"
                }
            }
        )
        
        # Demand Concepts - Updated to clarify power vs energy distinction and geographic levels
        self.concepts["maximum_demand"] = EnergyConcept(
            id="maximum_demand",
            name="Maximum Demand",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.DEMAND,
            description="Maximum power demand observed during the entire day (instantaneous measurement)",
            synonyms=["peak demand", "maximum power demand", "maximum demand", "peak load", "peak power demand"],
            database_mapping={
                "state_table": "FactStateDailyEnergy",
                "state_column": "MaximumDemand",
                "region_table": "FactAllIndiaDailySummary", 
                "region_column": "MaxDemandSCADA"
            },
            attributes={
                "unit": "MW",
                "measurement_type": "instantaneous",
                "description": "Maximum power demand observed during the entire day. This represents the maximum power (capacity) required. Measured at both state level (FactStateDailyEnergy.MaximumDemand) and region level (FactAllIndiaDailySummary.MaxDemandSCADA).",
                "geographic_levels": ["state", "region"],
                "state_mapping": {
                    "table": "FactStateDailyEnergy",
                    "column": "MaximumDemand"
                },
                "region_mapping": {
                    "table": "FactAllIndiaDailySummary", 
                    "column": "MaxDemandSCADA"
                }
            }
        )
        
        self.concepts["time_of_maximum_demand"] = EnergyConcept(
            id="time_of_maximum_demand",
            name="Time of Maximum Demand",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.DEMAND,
            description="Time when maximum power demand was observed during the day (region level only)",
            synonyms=["time of peak demand", "maximum demand time", "peak demand time"],
            database_mapping={
                "table": "FactAllIndiaDailySummary",
                "column": "TimeOfMaxDemandMet"
            },
            attributes={
                "unit": "time",
                "measurement_type": "instantaneous",
                "description": "Time when maximum power demand was observed during the day. This is measured only at region level.",
                "geographic_levels": ["region"],
                "time_format": "HH:MM",
                "data_type": "time"
            }
        )
        
        self.concepts["evening_peak_demand"] = EnergyConcept(
            id="evening_peak_demand",
            name="Evening Peak Demand",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.DEMAND,
            description="Maximum power demand observed in the peak evening time specifically at 7 pm or 8 pm (region level only)",
            synonyms=["evening peak", "evening load", "evening peak demand"],
            database_mapping={
                "table": "FactAllIndiaDailySummary",
                "column": "EveningPeakDemandMet"
            },
            attributes={
                "unit": "MW",
                "measurement_type": "instantaneous",
                "description": "Maximum power demand observed in the peak evening time specifically at 7 pm or 8 pm. This is measured only at region level.",
                "geographic_levels": ["region"],
                "time_period": "evening_peak_hours"
            }
        )
        
        self.concepts["demand_met"] = EnergyConcept(
            id="demand_met",
            name="Demand Met",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.DEMAND,
            description="Demand that was successfully met (context-aware: timeblock vs state/region level, energy vs power demand)",
            synonyms=["met demand", "satisfied demand"],
            database_mapping={
                "timeblock_table": "FactTimeBlockPowerData",
                "timeblock_column": "DemandMet",
                "state_table": "FactStateDailyEnergy", 
                "state_column": "EnergyMet",  # Using EnergyMet as proxy since DemandMet not available
                "region_table": "FactAllIndiaDailySummary",
                "region_column": "EnergyMet"  # Using EnergyMet as proxy for demand met at region level
            },
            attributes={
                "unit": "MW/MU",
                "measurement_type": "context_dependent",
                "description": "Demand that was successfully met. Context-aware mapping: uses FactTimeBlockPowerData.DemandMet only when timeblock/blockwise keywords are present, otherwise uses state level (FactStateDailyEnergy.EnergyMet as proxy) or region level (FactAllIndiaDailySummary.EnergyMet as proxy) based on state/region keywords in query. AMBIGUOUS: Can refer to energy demand (cumulative) or power demand (instantaneous/peak).",
                "geographic_levels": ["state", "region", "timeblock"],
                "ambiguity_detection": {
                    "energy_keywords": ["energy", "consumption", "daily", "total", "cumulative"],
                    "power_keywords": ["power", "peak", "instantaneous", "maximum", "capacity"],
                    "clarification_question": "When you mention 'demand met', do you mean:\n1. Energy demand met (total energy consumed/supplied over a period) - measured in MU\n2. Power demand met (instantaneous power demand at peak time) - measured in MW\n\nPlease specify which type of demand you're interested in.",
                    "requires_clarification": True
                },
                "context_rules": {
                    "timeblock_keywords": ["block", "blockwise", "timeblock", "time block"],
                    "state_keywords": ["state", "states", "statewise"],
                    "region_keywords": ["region", "regions", "regionwise"],
                    "default_level": "region",
                    "state_proxy": "EnergyMet",
                    "region_proxy": "EnergyMet"
                },
                "timeblock_mapping": {
                    "table": "FactTimeBlockPowerData",
                    "column": "DemandMet"
                },
                "state_mapping": {
                    "table": "FactStateDailyEnergy",
                    "column": "EnergyMet"  # Using EnergyMet as proxy since DemandMet not available
                },
                "region_mapping": {
                    "table": "FactAllIndiaDailySummary",
                    "column": "EnergyMet"  # Using EnergyMet as proxy since DemandMet not available
                }
            }
        )
        
        self.concepts["net_demand_met"] = EnergyConcept(
            id="net_demand_met",
            name="Net Demand Met",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.DEMAND,
            description="Net demand that was successfully met (context-aware: timeblock vs state/region level, energy vs power demand)",
            synonyms=["net met demand", "net satisfied demand"],
            database_mapping={
                "timeblock_table": "FactTimeBlockPowerData",
                "timeblock_column": "NetDemandMet",
                "state_table": "FactStateDailyEnergy",
                "state_column": "EnergyMet",  # Using EnergyMet as proxy since NetDemandMet not available
                "region_table": "FactAllIndiaDailySummary", 
                "region_column": "EnergyMet"  # Using EnergyMet as proxy since NetDemandMet not available
            },
            attributes={
                "unit": "MW/MU",
                "measurement_type": "context_dependent",
                "description": "Net demand that was successfully met. Context-aware mapping: uses FactTimeBlockPowerData.NetDemandMet only when timeblock/blockwise keywords are present, otherwise uses state level (FactStateDailyEnergy.EnergyMet as proxy) or region level (FactAllIndiaDailySummary.EnergyMet as proxy) based on state/region keywords in query. AMBIGUOUS: Can refer to energy demand (cumulative) or power demand (instantaneous/peak).",
                "geographic_levels": ["state", "region", "timeblock"],
                "ambiguity_detection": {
                    "energy_keywords": ["energy", "consumption", "daily", "total", "cumulative"],
                    "power_keywords": ["power", "peak", "instantaneous", "maximum", "capacity"],
                    "clarification_question": "When you mention 'net demand met', do you mean:\n1. Net energy demand met (total net energy consumed/supplied over a period) - measured in MU\n2. Net power demand met (instantaneous net power demand at peak time) - measured in MW\n\nPlease specify which type of demand you're interested in.",
                    "requires_clarification": True
                },
                "context_rules": {
                    "timeblock_keywords": ["block", "blockwise", "timeblock", "time block"],
                    "state_keywords": ["state", "states", "statewise"],
                    "region_keywords": ["region", "regions", "regionwise"],
                    "default_level": "region",
                    "state_proxy": "EnergyMet",
                    "region_proxy": "EnergyMet"
                },
                "timeblock_mapping": {
                    "table": "FactTimeBlockPowerData",
                    "column": "NetDemandMet"
                },
                "state_mapping": {
                    "table": "FactStateDailyEnergy",
                    "column": "EnergyMet"  # Using EnergyMet as proxy since NetDemandMet not available
                },
                "region_mapping": {
                    "table": "FactAllIndiaDailySummary",
                    "column": "EnergyMet"  # Using EnergyMet as proxy since NetDemandMet not available
                }
            }
        )
        
        # Shortage Concepts - Updated to clarify geographic levels
        self.concepts["energy_shortage"] = EnergyConcept(
            id="energy_shortage",
            name="Energy Shortage",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.SHORTAGE,
            description="Energy shortage during a period (cumulative measurement)",
            synonyms=["shortage", "energy deficit", "power shortage"],
            database_mapping={
                "state_table": "FactStateDailyEnergy",
                "state_column": "EnergyShortage",
                "region_table": "FactAllIndiaDailySummary",
                "region_column": "EnergyShortage"
            },
            attributes={
                "unit": "MU",
                "measurement_type": "cumulative",
                "description": "Energy shortage during a period. Measured at both state level (FactStateDailyEnergy.EnergyShortage) and region level (FactAllIndiaDailySummary.EnergyShortage).",
                "geographic_levels": ["state", "region"],
                "state_mapping": {
                    "table": "FactStateDailyEnergy",
                    "column": "EnergyShortage"
                },
                "region_mapping": {
                    "table": "FactAllIndiaDailySummary",
                    "column": "EnergyShortage"
                }
            }
        )
        
        self.concepts["peak_shortage"] = EnergyConcept(
            id="peak_shortage",
            name="Peak Shortage",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.SHORTAGE,
            description="Power shortage during peak demand (instantaneous measurement)",
            synonyms=["peak deficit", "maximum shortage"],
            database_mapping={
                "state_table": "FactStateDailyEnergy",
                "state_column": "Shortage",  # May need to be updated if column name is different
                "region_table": "FactAllIndiaDailySummary",
                "region_column": "PeakShortage"
            },
            attributes={
                "unit": "MW",
                "measurement_type": "instantaneous",
                "description": "Power shortage during peak demand. Measured at both state level (FactStateDailyEnergy.PeakShortage) and region level (FactAllIndiaDailySummary.PeakShortage).",
                "geographic_levels": ["state", "region"],
                "state_mapping": {
                    "table": "FactStateDailyEnergy",
                    "column": "Shortage"  # May need to be updated if column name is different
                },
                "region_mapping": {
                    "table": "FactAllIndiaDailySummary",
                    "column": "PeakShortage"
                }
            }
        )
        
        self.concepts["shortage"] = EnergyConcept(
            id="shortage",
            name="Shortage",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.SHORTAGE,
            description="Power shortage at state level",
            synonyms=["state shortage", "power deficit"],
            database_mapping={
                "table": "FactStateDailyEnergy",
                "column": "Shortage"
            },
            attributes={
                "unit": "MW",
                "measurement_type": "instantaneous"
            }
        )
        
        # Geographic Concepts
        self.concepts["state"] = EnergyConcept(
            id="state",
            name="State",
            concept_type=EnergyConceptType.ENTITY,
            domain=EnergyDomain.DISTRIBUTION,
            description="Geographic state for energy data",
            synonyms=["state", "territory"],
            database_mapping={
                "table": "DimStates",
                "column": "StateName"
            }
        )
        
        self.concepts["region"] = EnergyConcept(
            id="region",
            name="Region",
            concept_type=EnergyConceptType.ENTITY,
            domain=EnergyDomain.DISTRIBUTION,
            description="Geographic region for energy data. All regions belong to India, and India itself is also referred to as a region in DimRegions. FactAllIndiaDailySummary contains India data as a region.",
            synonyms=["region", "zone", "india"],
            database_mapping={
                "table": "DimRegions",
                "column": "RegionName"
            },
            attributes={
                "geographic_hierarchy": {
                    "country": "India",
                    "description": "All regions belong to India",
                    "special_case": "India itself is also a region in DimRegions"
                },
                "data_source": {
                    "table": "FactAllIndiaDailySummary",
                    "description": "Contains India data as a region"
                }
            }
        )
        
        self.concepts["country"] = EnergyConcept(
            id="country",
            name="Country",
            concept_type=EnergyConceptType.ENTITY,
            domain=EnergyDomain.DISTRIBUTION,
            description="Country for energy data. India is the primary country, and all regions belong to India.",
            synonyms=["country", "nation", "india"],
            database_mapping={
                "table": "DimCountries",
                "column": "CountryName"
            },
            attributes={
                "primary_country": "India",
                "description": "India is the primary country for all energy data"
            }
        )
        
        # Temporal Concepts
        self.concepts["date"] = EnergyConcept(
            id="date",
            name="Date",
            concept_type=EnergyConceptType.ENTITY,
            domain=EnergyDomain.DISTRIBUTION,
            description="Temporal dimension for energy data",
            synonyms=["date", "time", "period"],
            database_mapping={
                "table": "DimDates",
                "column": "ActualDate"
            }
        )
        
        self.concepts["time_block"] = EnergyConcept(
            id="time_block",
            name="Time Block",
            concept_type=EnergyConceptType.ENTITY,
            domain=EnergyDomain.DISTRIBUTION,
            description="Time block of 15-minute intervals for granular energy data",
            synonyms=["block", "time period", "interval"],
            database_mapping={
                "table": "FactTimeBlockPowerData",
                "column": "BlockTime"
            }
        )
        
        # Exchange Concepts
        self.concepts["power_exchange"] = EnergyConcept(
            id="power_exchange",
            name="Power Exchange",
            concept_type=EnergyConceptType.ENTITY,
            domain=EnergyDomain.EXCHANGE,
            description="Energy exchange between regions or countries through the commercial power exchanges",
            synonyms=["exchange", "power transfer", "energy exchange"],
            database_mapping={
                "table": "FactTransnationalExchangeDetail",
                "column": "ExchangeValue"
            },
            attributes={
                "unit": "MU",
                "measurement_type": "cumulative"
            }
        )
        
        self.concepts["exchange_mechanism"] = EnergyConcept(
            id="exchange_mechanism",
            name="Exchange Mechanism",
            concept_type=EnergyConceptType.ENTITY,
            domain=EnergyDomain.EXCHANGE,
            description="Mechanism used for power exchange",
            synonyms=["mechanism", "exchange type"],
            database_mapping={
                "table": "DimExchangeMechanisms",
                "column": "MechanismName"
            }
        )
        
        self.concepts["exchange_direction"] = EnergyConcept(
            id="exchange_direction",
            name="Exchange Direction",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.EXCHANGE,
            description="Direction of power exchange (import/export/net import)",
            synonyms=["direction", "flow direction"],
            database_mapping={
                "table": "FactTransnationalExchangeDetail",
                "column": "ExchangeDirection"
            }
        )
        
        self.concepts["total_energy_exchanged"] = EnergyConcept(
            id="total_energy_exchanged",
            name="Total Energy Exchanged",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.EXCHANGE,
            description="Total energy exchanged with a country",
            synonyms=["total exchange", "energy exchange"],
            database_mapping={
                "table": "FactCountryDailyExchange",
                "column": "TotalEnergyExchanged"
            },
            attributes={
                "unit": "MU",
                "measurement_type": "cumulative"
            }
        )
        
        self.concepts["peak_exchange"] = EnergyConcept(
            id="peak_exchange",
            name="Peak Exchange",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.EXCHANGE,
            description="Peak power exchange with a country",
            synonyms=["peak exchange", "maximum exchange"],
            database_mapping={
                "table": "FactCountryDailyExchange",
                "column": "PeakExchange"
            },
            attributes={
                "unit": "MW",
                "measurement_type": "instantaneous"
            }
        )
        
        # Transmission Concepts
        self.concepts["transmission_line"] = EnergyConcept(
            id="transmission_line",
            name="Transmission Line",
            concept_type=EnergyConceptType.ENTITY,
            domain=EnergyDomain.TRANSMISSION,
            description="Power transmission line",
            synonyms=["line", "transmission", "power line"],
            database_mapping={
                "table": "DimTransmissionLines",
                "column": "LineIdentifier"
            }
        )
        
        self.concepts["voltage_level"] = EnergyConcept(
            id="voltage_level",
            name="Voltage Level",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.TRANSMISSION,
            description="Voltage level of transmission line",
            synonyms=["voltage", "kv level"],
            database_mapping={
                "table": "DimTransmissionLines",
                "column": "VoltageLevel_kV"
            },
            attributes={
                "unit": "kV"
            }
        )
        
        self.concepts["max_import"] = EnergyConcept(
            id="max_import",
            name="Maximum Import",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.TRANSMISSION,
            description="Maximum power import capacity",
            synonyms=["max import", "import capacity"],
            database_mapping={
                "table": "FactTransmissionLinkFlow",
                "column": "MaxImport"
            },
            attributes={
                "unit": "MW",
                "measurement_type": "instantaneous"
            }
        )
        
        self.concepts["max_export"] = EnergyConcept(
            id="max_export",
            name="Maximum Export",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.TRANSMISSION,
            description="Maximum power export capacity",
            synonyms=["max export", "export capacity"],
            database_mapping={
                "table": "FactTransmissionLinkFlow",
                "column": "MaxExport"
            },
            attributes={
                "unit": "MW",
                "measurement_type": "instantaneous"
            }
        )
        
        self.concepts["import_energy"] = EnergyConcept(
            id="import_energy",
            name="Import Energy",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.TRANSMISSION,
            description="Energy imported through transmission line",
            synonyms=["imported energy", "energy import"],
            database_mapping={
                "table": "FactTransmissionLinkFlow",
                "column": "ImportEnergy"
            },
            attributes={
                "unit": "MU",
                "measurement_type": "cumulative"
            }
        )
        
        self.concepts["export_energy"] = EnergyConcept(
            id="export_energy",
            name="Export Energy",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.TRANSMISSION,
            description="Energy exported through transmission line",
            synonyms=["exported energy", "energy export"],
            database_mapping={
                "table": "FactTransmissionLinkFlow",
                "column": "ExportEnergy"
            },
            attributes={
                "unit": "MU",
                "measurement_type": "cumulative"
            }
        )
        
        self.concepts["net_import_energy"] = EnergyConcept(
            id="net_import_energy",
            name="Net Import Energy",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.TRANSMISSION,
            description="Net energy imported through transmission line",
            synonyms=["net import", "net energy import"],
            database_mapping={
                "table": "FactTransmissionLinkFlow",
                "column": "NetImportEnergy"
            },
            attributes={
                "unit": "MU",
                "measurement_type": "cumulative"
            }
        )
        
        # Loading Concepts
        self.concepts["max_loading"] = EnergyConcept(
            id="max_loading",
            name="Maximum Loading",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.TRANSMISSION,
            description="Maximum loading of transmission line",
            synonyms=["max loading", "peak loading"],
            database_mapping={
                "table": "FactInternationalTransmissionLinkFlow",
                "column": "MaxLoading"
            },
            attributes={
                "unit": "MW",
                "measurement_type": "instantaneous"
            }
        )
        
        self.concepts["min_loading"] = EnergyConcept(
            id="min_loading",
            name="Minimum Loading",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.TRANSMISSION,
            description="Minimum loading of transmission line",
            synonyms=["min loading", "minimum loading"],
            database_mapping={
                "table": "FactInternationalTransmissionLinkFlow",
                "column": "MinLoading"
            },
            attributes={
                "unit": "MW",
                "measurement_type": "instantaneous"
            }
        )
        
        self.concepts["avg_loading"] = EnergyConcept(
            id="avg_loading",
            name="Average Loading",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.TRANSMISSION,
            description="Average loading of transmission line",
            synonyms=["average loading", "mean loading"],
            database_mapping={
                "table": "FactInternationalTransmissionLinkFlow",
                "column": "AvgLoading"
            },
            attributes={
                "unit": "MW",
                "measurement_type": "instantaneous"
            }
        )
        
        # System Concepts
        self.concepts["frequency"] = EnergyConcept(
            id="frequency",
            name="Frequency",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.RELIABILITY,
            description="System frequency in the time block",
            synonyms=["frequency","system frequency", "grid frequency"],
            database_mapping={
                "table": "FactTimeBlockPowerData",
                "column": "Frequency"
            },
            attributes={
                "unit": "Hz",
                "measurement_type": "instantaneous"
            }
        )
        
        self.concepts["total_generation"] = EnergyConcept(
            id="total_generation",
            name="Total Generation power",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.GENERATION,
            description="Total generating power utilized in the time block",
            synonyms=["total generation", "overall generation"],
            database_mapping={
                "table": "FactTimeBlockPowerData",
                "column": "TotalGeneration"
            },
            attributes={
                "unit": "MW",
                "measurement_type": "instantaneous"
            }
        )
        
        self.concepts["net_transnational_exchange"] = EnergyConcept(
            id="net_transnational_exchange",
            name="Net Transnational Exchange",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.EXCHANGE,
            description="Net power utilized through power exchanges across national borders",
            synonyms=["net exchange", "transnational exchange"],
            database_mapping={
                "table": "FactTimeBlockPowerData",
                "column": "NetTransnationalExchange"
            },
            attributes={
                "unit": "MW",
                "measurement_type": "instantaneous"
            }
        )
        
        # Units and Measurements
        self.concepts["unit"] = EnergyConcept(
            id="unit",
            name="Unit",
            concept_type=EnergyConceptType.ENTITY,
            domain=EnergyDomain.DISTRIBUTION,
            description="Unit of measurement",
            synonyms=["unit", "measurement unit"],
            database_mapping={
                "table": "DimUnits",
                "column": "UnitName"
            }
        )
        
        self.concepts["unit_symbol"] = EnergyConcept(
            id="unit_symbol",
            name="Unit Symbol",
            concept_type=EnergyConceptType.ATTRIBUTE,
            domain=EnergyDomain.DISTRIBUTION,
            description="Symbol for unit of measurement",
            synonyms=["symbol", "unit symbol"],
            database_mapping={
                "table": "DimUnits",
                "column": "UnitSymbol"
            }
        )
        
        # Reports
        self.concepts["report"] = EnergyConcept(
            id="report",
            name="Report",
            concept_type=EnergyConceptType.ENTITY,
            domain=EnergyDomain.DISTRIBUTION,
            description="Energy report",
            synonyms=["report", "document"],
            database_mapping={
                "table": "DimReports",
                "column": "ReportName"
            }
        )
    
    def _initialize_relationships(self):
        """Initialize relationships between energy concepts"""
        
        # Geographic relationships
        self.relationships["state_belongs_to_region"] = OntologyRelationship(
            id="state_belongs_to_region",
            source_concept="state",
            target_concept="region",
            relationship_type="belongs_to",
            description="A state belongs to a region",
            cardinality="N:1"
        )
        
        self.relationships["region_belongs_to_country"] = OntologyRelationship(
            id="region_belongs_to_country",
            source_concept="region",
            target_concept="country",
            relationship_type="belongs_to",
            description="A region belongs to a country",
            cardinality="N:1"
        )
        
        # Temporal relationships
        self.relationships["data_has_date"] = OntologyRelationship(
            id="data_has_date",
            source_concept="date",
            target_concept="energy_consumption",
            relationship_type="temporal",
            description="Energy data is associated with a date",
            cardinality="1:N"
        )
        
        self.relationships["data_has_time_block"] = OntologyRelationship(
            id="data_has_time_block",
            source_concept="time_block",
            target_concept="energy_consumption",
            relationship_type="temporal",
            description="Energy data is associated with a time block",
            cardinality="1:N"
        )
        
        # Generation relationships
        self.relationships["energy_generation_has_source"] = OntologyRelationship(
            id="energy_generation_has_source",
            source_concept="energy_generation",
            target_concept="generation_source",
            relationship_type="has_source",
            description="Energy generation has a specific source",
            cardinality="N:1"
        )
        
        self.relationships["power_generation_has_source"] = OntologyRelationship(
            id="power_generation_has_source",
            source_concept="power_generation",
            target_concept="generation_source",
            relationship_type="has_source",
            description="Power generation has a specific source",
            cardinality="N:1"
        )
        
        self.relationships["energy_generation_to_power_generation"] = OntologyRelationship(
            id="energy_generation_to_power_generation",
            source_concept="energy_generation",
            target_concept="power_generation",
            relationship_type="converts_to",
            description="Energy generation (cumulative) converts to power generation (instantaneous) over time",
            cardinality="1:N"
        )
        
        # Demand relationships
        self.relationships["demand_has_shortage"] = OntologyRelationship(
            id="demand_has_shortage",
            source_concept="maximum_demand",
            target_concept="energy_shortage",
            relationship_type="causes",
            description="Maximum demand can cause energy shortage",
            cardinality="1:N"
        )
        
        self.relationships["demand_met_has_demand"] = OntologyRelationship(
            id="demand_met_has_demand",
            source_concept="demand_met",
            target_concept="maximum_demand",
            relationship_type="is_met_by",
            description="Demand met is the result of meeting demand",
            cardinality="1:N"
        )
        
        self.relationships["net_demand_met_has_demand"] = OntologyRelationship(
            id="net_demand_met_has_demand",
            source_concept="net_demand_met",
            target_concept="maximum_demand",
            relationship_type="is_met_by",
            description="Net demand met is the result of meeting net demand",
            cardinality="1:N"
        )
        
        # Shortage relationships
        self.relationships["shortage_has_demand"] = OntologyRelationship(
            id="shortage_has_demand",
            source_concept="shortage",
            target_concept="maximum_demand",
            relationship_type="causes",
            description="State shortage causes maximum demand",
            cardinality="1:N"
        )
        
        # Geographic data relationships
        self.relationships["state_has_demand"] = OntologyRelationship(
            id="state_has_demand",
            source_concept="state",
            target_concept="maximum_demand",
            relationship_type="has",
            description="A state has maximum demand data",
            cardinality="1:N"
        )
        
        self.relationships["region_has_consumption"] = OntologyRelationship(
            id="region_has_consumption",
            source_concept="region",
            target_concept="energy_consumption",
            relationship_type="has",
            description="A region has energy consumption data",
            cardinality="1:N"
        )
        
        self.relationships["country_has_exchange"] = OntologyRelationship(
            id="country_has_exchange",
            source_concept="country",
            target_concept="power_exchange",
            relationship_type="has",
            description="A country has power exchange data",
            cardinality="1:N"
        )
        
        # Exchange relationships
        self.relationships["exchange_mechanism_has_exchange"] = OntologyRelationship(
            id="exchange_mechanism_has_exchange",
            source_concept="exchange_mechanism",
            target_concept="power_exchange",
            relationship_type="is_mechanism_of",
            description="An exchange mechanism is used for a power exchange",
            cardinality="N:1"
        )
        
        self.relationships["exchange_direction_has_exchange"] = OntologyRelationship(
            id="exchange_direction_has_exchange",
            source_concept="exchange_direction",
            target_concept="power_exchange",
            relationship_type="is_direction_of",
            description="An exchange direction is for a power exchange",
            cardinality="N:1"
        )
        
        self.relationships["total_energy_exchanged_has_exchange"] = OntologyRelationship(
            id="total_energy_exchanged_has_exchange",
            source_concept="total_energy_exchanged",
            target_concept="power_exchange",
            relationship_type="is_exchanged_with",
            description="Total energy exchanged is for a power exchange",
            cardinality="1:N"
        )
        
        self.relationships["peak_exchange_has_exchange"] = OntologyRelationship(
            id="peak_exchange_has_exchange",
            source_concept="peak_exchange",
            target_concept="power_exchange",
            relationship_type="is_peak_of",
            description="Peak exchange is for a power exchange",
            cardinality="1:N"
        )
        
        # Transmission relationships
        self.relationships["transmission_line_has_voltage_level"] = OntologyRelationship(
            id="transmission_line_has_voltage_level",
            source_concept="transmission_line",
            target_concept="voltage_level",
            relationship_type="has",
            description="A transmission line has a voltage level",
            cardinality="1:N"
        )
        
        self.relationships["max_import_has_transmission_line"] = OntologyRelationship(
            id="max_import_has_transmission_line",
            source_concept="max_import",
            target_concept="transmission_line",
            relationship_type="is_capacity_of",
            description="Maximum import is a capacity of a transmission line",
            cardinality="1:N"
        )
        
        self.relationships["max_export_has_transmission_line"] = OntologyRelationship(
            id="max_export_has_transmission_line",
            source_concept="max_export",
            target_concept="transmission_line",
            relationship_type="is_capacity_of",
            description="Maximum export is a capacity of a transmission line",
            cardinality="1:N"
        )
        
        self.relationships["import_energy_has_transmission_line"] = OntologyRelationship(
            id="import_energy_has_transmission_line",
            source_concept="import_energy",
            target_concept="transmission_line",
            relationship_type="is_energy_of",
            description="Import energy is for a transmission line",
            cardinality="1:N"
        )
        
        self.relationships["export_energy_has_transmission_line"] = OntologyRelationship(
            id="export_energy_has_transmission_line",
            source_concept="export_energy",
            target_concept="transmission_line",
            relationship_type="is_energy_of",
            description="Export energy is for a transmission line",
            cardinality="1:N"
        )
        
        self.relationships["net_import_energy_has_transmission_line"] = OntologyRelationship(
            id="net_import_energy_has_transmission_line",
            source_concept="net_import_energy",
            target_concept="transmission_line",
            relationship_type="is_energy_of",
            description="Net import energy is for a transmission line",
            cardinality="1:N"
        )
        
        # Loading relationships
        self.relationships["max_loading_has_transmission_line"] = OntologyRelationship(
            id="max_loading_has_transmission_line",
            source_concept="max_loading",
            target_concept="transmission_line",
            relationship_type="is_loading_of",
            description="Maximum loading is a loading of a transmission line",
            cardinality="1:N"
        )
        
        self.relationships["min_loading_has_transmission_line"] = OntologyRelationship(
            id="min_loading_has_transmission_line",
            source_concept="min_loading",
            target_concept="transmission_line",
            relationship_type="is_loading_of",
            description="Minimum loading is a loading of a transmission line",
            cardinality="1:N"
        )
        
        self.relationships["avg_loading_has_transmission_line"] = OntologyRelationship(
            id="avg_loading_has_transmission_line",
            source_concept="avg_loading",
            target_concept="transmission_line",
            relationship_type="is_loading_of",
            description="Average loading is a loading of a transmission line",
            cardinality="1:N"
        )
        
        # System relationships
        self.relationships["frequency_has_time_block"] = OntologyRelationship(
            id="frequency_has_time_block",
            source_concept="frequency",
            target_concept="time_block",
            relationship_type="is_measured_at",
            description="Frequency is measured at a time block",
            cardinality="1:N"
        )
        
        self.relationships["total_generation_has_time_block"] = OntologyRelationship(
            id="total_generation_has_time_block",
            source_concept="total_generation",
            target_concept="time_block",
            relationship_type="is_measured_at",
            description="Total generation is measured at a time block",
            cardinality="1:N"
        )
        
        self.relationships["net_transnational_exchange_has_time_block"] = OntologyRelationship(
            id="net_transnational_exchange_has_time_block",
            source_concept="net_transnational_exchange",
            target_concept="time_block",
            relationship_type="is_measured_at",
            description="Net transnational exchange is measured at a time block",
            cardinality="1:N"
        )
        
        # Units and Measurements relationships
        self.relationships["unit_symbol_has_unit"] = OntologyRelationship(
            id="unit_symbol_has_unit",
            source_concept="unit_symbol",
            target_concept="unit",
            relationship_type="is_symbol_of",
            description="A unit symbol is the symbol for a unit",
            cardinality="1:N"
        )
        
        # Reports relationships
        self.relationships["report_has_date"] = OntologyRelationship(
            id="report_has_date",
            source_concept="report",
            target_concept="date",
            relationship_type="is_for",
            description="A report is for a date",
            cardinality="1:N"
        )
    
    def _initialize_business_rules(self):
        """Initialize business rules for the energy domain"""
        
        # Validation rules
        self.business_rules["positive_energy_values"] = BusinessRule(
            id="positive_energy_values",
            name="Positive Energy Values",
            description="Energy values should be positive",
            rule_type="validation",
            expression="value >= 0",
            severity="error",
            applicable_domains=[EnergyDomain.GENERATION, EnergyDomain.CONSUMPTION, EnergyDomain.DEMAND]
        )
        
        self.business_rules["demand_greater_than_shortage"] = BusinessRule(
            id="demand_greater_than_shortage",
            name="Demand Greater Than Shortage",
            description="Maximum demand should be greater than or equal to shortage",
            rule_type="validation",
            expression="maximum_demand >= energy_shortage",
            severity="error",
            applicable_domains=[EnergyDomain.DEMAND, EnergyDomain.SHORTAGE]
        )
        
        self.business_rules["energy_met_plus_shortage"] = BusinessRule(
            id="energy_met_plus_shortage",
            name="Energy Met Plus Shortage",
            description="Energy met plus energy shortage should equal total demand",
            rule_type="validation",
            expression="energy_met + energy_shortage = total_demand",
            severity="warning",
            applicable_domains=[EnergyDomain.CONSUMPTION, EnergyDomain.SHORTAGE]
        )
        
        # Generation rules - Updated for power vs energy distinction
        self.business_rules["energy_generation_positive"] = BusinessRule(
            id="energy_generation_positive",
            name="Energy Generation Positive",
            description="Energy generation should be positive (cumulative measurement)",
            rule_type="validation",
            expression="energy_generation >= 0",
            severity="error",
            applicable_domains=[EnergyDomain.GENERATION]
        )
        
        self.business_rules["power_generation_positive"] = BusinessRule(
            id="power_generation_positive",
            name="Power Generation Positive",
            description="Power generation should be positive (instantaneous measurement)",
            rule_type="validation",
            expression="power_generation >= 0",
            severity="error",
            applicable_domains=[EnergyDomain.GENERATION]
        )
        
        self.business_rules["energy_power_relationship"] = BusinessRule(
            id="energy_power_relationship",
            name="Energy Power Relationship",
            description="Energy is power multiplied by time. Energy generation (MWh) should equal power generation (MW) multiplied by time period (hours)",
            rule_type="validation",
            expression="energy_generation = power_generation * time_period_hours",
            severity="warning",
            applicable_domains=[EnergyDomain.GENERATION]
        )
        
        self.business_rules["total_energy_generation_sum"] = BusinessRule(
            id="total_energy_generation_sum",
            name="Total Energy Generation Sum",
            description="Total energy generation should equal sum of individual energy generation sources",
            rule_type="validation",
            expression="total_energy_generation = sum(energy_generation)",
            severity="warning",
            applicable_domains=[EnergyDomain.GENERATION]
        )
        
        self.business_rules["total_power_generation_sum"] = BusinessRule(
            id="total_power_generation_sum",
            name="Total Power Generation Sum",
            description="Total power generation should equal sum of individual power generation sources",
            rule_type="validation",
            expression="total_power_generation = sum(power_generation)",
            severity="warning",
            applicable_domains=[EnergyDomain.GENERATION]
        )
        
        # Demand rules
        self.business_rules["demand_met_less_than_maximum"] = BusinessRule(
            id="demand_met_less_than_maximum",
            name="Demand Met Less Than Maximum",
            description="Demand met should be less than or equal to maximum demand",
            rule_type="validation",
            expression="demand_met <= maximum_demand",
            severity="error",
            applicable_domains=[EnergyDomain.DEMAND]
        )
        
        self.business_rules["net_demand_met_less_than_demand"] = BusinessRule(
            id="net_demand_met_less_than_demand",
            name="Net Demand Met Less Than Demand",
            description="Net demand met should be less than or equal to demand met",
            rule_type="validation",
            expression="net_demand_met <= demand_met",
            severity="error",
            applicable_domains=[EnergyDomain.DEMAND]
        )
        
        # Exchange rules
        self.business_rules["exchange_direction_valid"] = BusinessRule(
            id="exchange_direction_valid",
            name="Exchange Direction Valid",
            description="Exchange direction should be either 'import' or 'export'",
            rule_type="validation",
            expression="exchange_direction IN ('import', 'export')",
            severity="error",
            applicable_domains=[EnergyDomain.EXCHANGE]
        )
        
        self.business_rules["peak_exchange_less_than_total"] = BusinessRule(
            id="peak_exchange_less_than_total",
            name="Peak Exchange Less Than Total",
            description="Peak exchange should be less than or equal to total energy exchanged",
            rule_type="validation",
            expression="peak_exchange <= total_energy_exchanged",
            severity="warning",
            applicable_domains=[EnergyDomain.EXCHANGE]
        )
        
        # Transmission rules
        self.business_rules["max_import_positive"] = BusinessRule(
            id="max_import_positive",
            name="Maximum Import Positive",
            description="Maximum import should be positive",
            rule_type="validation",
            expression="max_import >= 0",
            severity="error",
            applicable_domains=[EnergyDomain.TRANSMISSION]
        )
        
        self.business_rules["max_export_positive"] = BusinessRule(
            id="max_export_positive",
            name="Maximum Export Positive",
            description="Maximum export should be positive",
            rule_type="validation",
            expression="max_export >= 0",
            severity="error",
            applicable_domains=[EnergyDomain.TRANSMISSION]
        )
        
        self.business_rules["import_energy_less_than_max"] = BusinessRule(
            id="import_energy_less_than_max",
            name="Import Energy Less Than Max",
            description="Import energy should be less than or equal to maximum import",
            rule_type="validation",
            expression="import_energy <= max_import",
            severity="warning",
            applicable_domains=[EnergyDomain.TRANSMISSION]
        )
        
        self.business_rules["export_energy_less_than_max"] = BusinessRule(
            id="export_energy_less_than_max",
            name="Export Energy Less Than Max",
            description="Export energy should be less than or equal to maximum export",
            rule_type="validation",
            expression="export_energy <= max_export",
            severity="warning",
            applicable_domains=[EnergyDomain.TRANSMISSION]
        )
        
        # Loading rules
        self.business_rules["max_loading_greater_than_min"] = BusinessRule(
            id="max_loading_greater_than_min",
            name="Maximum Loading Greater Than Minimum",
            description="Maximum loading should be greater than or equal to minimum loading",
            rule_type="validation",
            expression="max_loading >= min_loading",
            severity="error",
            applicable_domains=[EnergyDomain.TRANSMISSION]
        )
        
        self.business_rules["avg_loading_between_min_max"] = BusinessRule(
            id="avg_loading_between_min_max",
            name="Average Loading Between Min Max",
            description="Average loading should be between minimum and maximum loading",
            rule_type="validation",
            expression="min_loading <= avg_loading <= max_loading",
            severity="warning",
            applicable_domains=[EnergyDomain.TRANSMISSION]
        )
        
        # System rules
        self.business_rules["frequency_range"] = BusinessRule(
            id="frequency_range",
            name="Frequency Range",
            description="System frequency should be within acceptable range (49.5-50.5 Hz)",
            rule_type="validation",
            expression="49.5 <= frequency <= 50.5",
            severity="error",
            applicable_domains=[EnergyDomain.RELIABILITY]
        )
        
        self.business_rules["voltage_level_positive"] = BusinessRule(
            id="voltage_level_positive",
            name="Voltage Level Positive",
            description="Voltage level should be positive",
            rule_type="validation",
            expression="voltage_level > 0",
            severity="error",
            applicable_domains=[EnergyDomain.TRANSMISSION]
        )
        
        # Calculation rules
        self.business_rules["shortage_percentage"] = BusinessRule(
            id="shortage_percentage",
            name="Shortage Percentage",
            description="Shortage percentage calculation",
            rule_type="calculation",
            expression="(energy_shortage / (energy_met + energy_shortage)) * 100",
            severity="info",
            applicable_domains=[EnergyDomain.SHORTAGE]
        )
        
        self.business_rules["loading_percentage"] = BusinessRule(
            id="loading_percentage",
            name="Loading Percentage",
            description="Loading percentage calculation",
            rule_type="calculation",
            expression="(avg_loading / max_loading) * 100",
            severity="info",
            applicable_domains=[EnergyDomain.TRANSMISSION]
        )
        
        self.business_rules["efficiency_calculation"] = BusinessRule(
            id="efficiency_calculation",
            name="Efficiency Calculation",
            description="System efficiency calculation",
            rule_type="calculation",
            expression="(energy_met / (energy_met + energy_shortage)) * 100",
            severity="info",
            applicable_domains=[EnergyDomain.EFFICIENCY]
        )
        
        # Constraint rules
        self.business_rules["maximum_demand_constraint"] = BusinessRule(
            id="maximum_demand_constraint",
            name="Maximum Demand Constraint",
            description="Maximum demand should not exceed system capacity",
            rule_type="constraint",
            expression="maximum_demand <= system_capacity",
            severity="error",
            applicable_domains=[EnergyDomain.DEMAND]
        )
        
        self.business_rules["generation_capacity_constraint"] = BusinessRule(
            id="generation_capacity_constraint",
            name="Generation Capacity Constraint",
            description="Generation output should not exceed generation capacity",
            rule_type="constraint",
            expression="power_generation <= generation_capacity",
            severity="error",
            applicable_domains=[EnergyDomain.GENERATION]
        )
        
        self.business_rules["transmission_capacity_constraint"] = BusinessRule(
            id="transmission_capacity_constraint",
            name="Transmission Capacity Constraint",
            description="Transmission loading should not exceed transmission capacity",
            rule_type="constraint",
            expression="max_loading <= transmission_capacity",
            severity="error",
            applicable_domains=[EnergyDomain.TRANSMISSION]
        )
        
        # Geographic rules
        self.business_rules["state_belongs_to_region"] = BusinessRule(
            id="state_belongs_to_region",
            name="State Belongs To Region",
            description="Every state should belong to a region",
            rule_type="validation",
            expression="state.region_id IS NOT NULL",
            severity="error",
            applicable_domains=[EnergyDomain.DISTRIBUTION]
        )
        
        self.business_rules["region_belongs_to_country"] = BusinessRule(
            id="region_belongs_to_country",
            name="Region Belongs To Country",
            description="Every region should belong to a country",
            rule_type="validation",
            expression="region.country_id IS NOT NULL",
            severity="error",
            applicable_domains=[EnergyDomain.DISTRIBUTION]
        )
        
        # Temporal rules
        self.business_rules["date_validity"] = BusinessRule(
            id="date_validity",
            name="Date Validity",
            description="Date should be valid and not in the future",
            rule_type="validation",
            expression="date <= current_date",
            severity="error",
            applicable_domains=[EnergyDomain.DISTRIBUTION]
        )
        
        self.business_rules["time_block_sequence"] = BusinessRule(
            id="time_block_sequence",
            name="Time Block Sequence",
            description="Time blocks should be in chronological sequence",
            rule_type="validation",
            expression="block_number > 0 AND block_number <= 96",
            severity="error",
            applicable_domains=[EnergyDomain.DISTRIBUTION]
        )
        
        # Data quality rules
        self.business_rules["data_completeness"] = BusinessRule(
            id="data_completeness",
            name="Data Completeness",
            description="Required fields should not be null",
            rule_type="validation",
            expression="required_fields IS NOT NULL",
            severity="error",
            applicable_domains=[EnergyDomain.GENERATION, EnergyDomain.CONSUMPTION, EnergyDomain.DEMAND]
        )
        
        self.business_rules["data_consistency"] = BusinessRule(
            id="data_consistency",
            name="Data Consistency",
            description="Data should be consistent across related tables",
            rule_type="validation",
            expression="related_data_consistent = true",
            severity="warning",
            applicable_domains=[EnergyDomain.GENERATION, EnergyDomain.CONSUMPTION, EnergyDomain.DEMAND]
        )
    
    def _load_database_schema(self):
        """Load database schema information"""
        if not self.db_path:
            logger.warning("No database path provided, skipping schema loading")
            return
        
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute("SELECT name FROM sqlite_master WHERE type='table'")
                tables = [row[0] for row in cursor.fetchall()]
                
                for table in tables:
                    if table.startswith('Dim') or table.startswith('Fact'):
                        cursor = conn.execute(f"PRAGMA table_info({table})")
                        columns = []
                        for row in cursor.fetchall():
                            columns.append({
                                'name': row[1],
                                'type': row[2],
                                'notnull': row[3],
                                'pk': row[5]
                            })
                        self.database_schema[table] = columns
                
                logger.info(f"Loaded schema for {len(self.database_schema)} tables")
        
        except Exception as e:
            logger.error(f"Error loading database schema: {e}")
            # Initialize with empty schema if loading fails
            self.database_schema = {}
    
    def get_concept_by_name(self, name: str) -> Optional[EnergyConcept]:
        """Get concept by name or synonym"""
        name_lower = name.lower()
        
        for concept in self.concepts.values():
            if concept.name.lower() == name_lower:
                return concept
            
            if name_lower in [syn.lower() for syn in concept.synonyms]:
                return concept
        
        return None
    
    def get_concepts_by_domain(self, domain: EnergyDomain) -> List[EnergyConcept]:
        """Get all concepts for a specific domain"""
        return [concept for concept in self.concepts.values() if concept.domain == domain]
    
    def get_database_mapping(self, concept_name: str) -> Optional[Dict[str, str]]:
        """Get database mapping for a concept"""
        concept = self.get_concept_by_name(concept_name)
        return concept.database_mapping if concept else None
    
    def validate_concept_usage(self, concept_name: str, context: Dict[str, Any]) -> Tuple[bool, List[str]]:
        """Validate if a concept is used correctly in a given context"""
        concept = self.get_concept_by_name(concept_name)
        if not concept:
            return False, [f"Unknown concept: {concept_name}"]
        
        errors = []
        
        # Check domain constraints
        if 'domain' in context and concept.domain != context['domain']:
            errors.append(f"Concept {concept_name} belongs to domain {concept.domain.value}, "
                         f"but context requires {context['domain'].value}")
        
        # Check business rules
        for rule_id in concept.validation_rules:
            if rule_id in self.business_rules:
                rule = self.business_rules[rule_id]
                # Apply rule validation logic here
                pass
        
        return len(errors) == 0, errors
    
    def get_related_concepts(self, concept_name: str) -> List[EnergyConcept]:
        """Get concepts related to a given concept"""
        related = []
        concept = self.get_concept_by_name(concept_name)
        if not concept:
            return related
        
        for relationship in self.relationships.values():
            if relationship.source_concept == concept.id:
                target_concept = self.concepts.get(relationship.target_concept)
                if target_concept:
                    related.append(target_concept)
            elif relationship.target_concept == concept.id:
                source_concept = self.concepts.get(relationship.source_concept)
                if source_concept:
                    related.append(source_concept)
        
        return related
    
    def suggest_concepts(self, query: str) -> List[EnergyConcept]:
        """Suggest relevant concepts based on a query"""
        query_lower = query.lower()
        suggestions = []
        
        for concept in self.concepts.values():
            # Check if concept name or synonyms match query
            if (concept.name.lower() in query_lower or 
                any(syn.lower() in query_lower for syn in concept.synonyms)):
                suggestions.append(concept)
        
        return suggestions
    
    def get_business_rules_for_domain(self, domain: EnergyDomain) -> List[BusinessRule]:
        """Get business rules applicable to a specific domain"""
        return [rule for rule in self.business_rules.values() 
                if domain in rule.applicable_domains]
    
    def export_ontology(self, file_path: str):
        """Export ontology to JSON file"""
        ontology_data = {
            "concepts": {k: {
                "id": v.id,
                "name": v.name,
                "concept_type": v.concept_type.value,
                "domain": v.domain.value,
                "description": v.description,
                "synonyms": v.synonyms,
                "attributes": v.attributes,
                "constraints": v.constraints,
                "database_mapping": v.database_mapping,
                "relationships": v.relationships,
                "validation_rules": v.validation_rules
            } for k, v in self.concepts.items()},
            "relationships": {k: {
                "id": v.id,
                "source_concept": v.source_concept,
                "target_concept": v.target_concept,
                "relationship_type": v.relationship_type,
                "description": v.description,
                "constraints": v.constraints,
                "cardinality": v.cardinality
            } for k, v in self.relationships.items()},
            "business_rules": {k: {
                "id": v.id,
                "name": v.name,
                "description": v.description,
                "rule_type": v.rule_type,
                "expression": v.expression,
                "severity": v.severity,
                "applicable_domains": [d.value for d in v.applicable_domains]
            } for k, v in self.business_rules.items()}
        }
        
        with open(file_path, 'w') as f:
            json.dump(ontology_data, f, indent=2)
        
        logger.info(f"Ontology exported to {file_path}")
    
    def import_ontology(self, file_path: str):
        """Import ontology from JSON file"""
        with open(file_path, 'r') as f:
            ontology_data = json.load(f)
        
        # Import concepts
        for k, v in ontology_data["concepts"].items():
            self.concepts[k] = EnergyConcept(
                id=v["id"],
                name=v["name"],
                concept_type=EnergyConceptType(v["concept_type"]),
                domain=EnergyDomain(v["domain"]),
                description=v["description"],
                synonyms=v["synonyms"],
                attributes=v["attributes"],
                constraints=v["constraints"],
                database_mapping=v["database_mapping"],
                relationships=v["relationships"],
                validation_rules=v["validation_rules"]
            )
        
        # Import relationships
        for k, v in ontology_data["relationships"].items():
            self.relationships[k] = OntologyRelationship(
                id=v["id"],
                source_concept=v["source_concept"],
                target_concept=v["target_concept"],
                relationship_type=v["relationship_type"],
                description=v["description"],
                constraints=v["constraints"],
                cardinality=v["cardinality"]
            )
        
        # Import business rules
        for k, v in ontology_data["business_rules"].items():
            self.business_rules[k] = BusinessRule(
                id=v["id"],
                name=v["name"],
                description=v["description"],
                rule_type=v["rule_type"],
                expression=v["expression"],
                severity=v["severity"],
                applicable_domains=[EnergyDomain(d) for d in v["applicable_domains"]]
            )
        
        logger.info(f"Ontology imported from {file_path}")

    def detect_ambiguity(self, query: str) -> Tuple[bool, Optional[str], Optional[EnergyConcept]]:
        """
        Detect if a query contains ambiguous concepts that require clarification.
        
        Returns:
            Tuple[bool, Optional[str], Optional[EnergyConcept]]: 
            - bool: True if ambiguity detected
            - Optional[str]: Clarification question if ambiguity detected
            - Optional[EnergyConcept]: The ambiguous concept if detected
        """
        query_lower = query.lower()
        detected_concepts = []
        
        for concept in self.concepts.values():
            # Check if concept has ambiguity detection configured
            if "ambiguity_detection" in concept.attributes:
                ambiguity_config = concept.attributes["ambiguity_detection"]
                
                # Check if concept is mentioned in the query (case-insensitive)
                concept_mentioned = False
                match_score = 0  # Higher score for more specific matches
                
                # Check exact name match (case-insensitive)
                if concept.name.lower() in query_lower:
                    concept_mentioned = True
                    match_score = len(concept.name.split())  # Higher score for multi-word concepts
                
                # Check synonyms (case-insensitive)
                if not concept_mentioned:
                    for synonym in concept.synonyms:
                        if synonym.lower() in query_lower:
                            concept_mentioned = True
                            match_score = len(synonym.split())
                            break
                
                # Check partial matches for multi-word concepts
                if not concept_mentioned:
                    concept_words = concept.name.lower().split()
                    if len(concept_words) > 1:
                        # Check if all words in the concept name are present in the query
                        if all(word in query_lower for word in concept_words):
                            concept_mentioned = True
                            match_score = len(concept_words)
                
                if concept_mentioned and ambiguity_config.get("requires_clarification", False):
                    # Check if the query already contains clarifying keywords
                    energy_keywords = ambiguity_config.get("energy_keywords", [])
                    power_keywords = ambiguity_config.get("power_keywords", [])
                    
                    has_energy_context = any(keyword in query_lower for keyword in energy_keywords)
                    has_power_context = any(keyword in query_lower for keyword in power_keywords)
                    
                    # If neither energy nor power context is clear, ambiguity exists
                    if not has_energy_context and not has_power_context:
                        detected_concepts.append((concept, match_score))
        
        # Return the concept with the highest match score (most specific match)
        if detected_concepts:
            detected_concepts.sort(key=lambda x: x[1], reverse=True)
            best_match_concept, _ = detected_concepts[0]
            clarification_question = best_match_concept.attributes["ambiguity_detection"]["clarification_question"]
            return True, clarification_question, best_match_concept
        
        return False, None, None
    
    def get_clarification_for_concept(self, concept_name: str) -> Optional[str]:
        """
        Get the clarification question for a specific concept if it's ambiguous.
        
        Args:
            concept_name: Name of the concept to check
            
        Returns:
            Optional[str]: Clarification question if the concept is ambiguous, None otherwise
        """
        concept = self.get_concept_by_name(concept_name)
        if concept and "ambiguity_detection" in concept.attributes:
            ambiguity_config = concept.attributes["ambiguity_detection"]
            if ambiguity_config.get("requires_clarification", False):
                return ambiguity_config.get("clarification_question", "")
        return None
